= Cats Documentation
Andrey Antukh & Alejandro Gómez
1.2.1
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:sectlinks:
:source-highlighter: pygments
:pygments-style: friendly

image:logo.png[cats logo]

== Introduction

Category Theory and algebraic abstractions for Clojure.


== Rationale

The main motivations for writing this library are:

* The existing libraries do not have support for ClojureScript.
* We do not intend to write a little Haskell inside Clojure. We have adopted a
  practical and Clojure like approach, always with correctness in mind.
* We do not like viral/copyleft like licenses and in contrast to other libraries
  cats is licensed under the BSD (2 clauses) license.
* We do not intend to only implement monads. Other category theory and algebraic
  abstractions are also first class in cats.


*Alternatives:*

* **algo.monads**: This is the official Clojure library for monads. Its approach
  for modeling monads is slightly limited, only supports the monad abstraction and
  does not have support for ClojureScript.
* **fluokitten**: Slightly unmaintaned by the original author. It is focused on
  being very practical without taking care of correctness (for example, it extends
  Clojure types with monadic abstractions that do not make sense). It has no
  support for ClojureScript either.
* **monads**: Is the most advanced monads library, supports also functors,
  applicatives and other related abstractions. It lacks a good and readable
  documentation, focus on correctness, has Haskell like sugar syntax (instead of
  Clojure like syntax) and does not have support for ClojureScript.

All listed alternatives are licensed with EPL or similar licenses.


== Project Maturity

_cats_ already reached the 1.0.0 version and the link:api/index.html#id[API] is
 settled.


== Install

The simplest way to use _cats_ in a Clojure project is by including
it as a dependency in your *_project.clj_*:

[source,clojure]
----
[funcool/cats "1.2.1"]
----

And it works with the following platforms: *jdk7*, *jdk8*, *node* (0.12.7, 4.2.0,
5.0.0).


== User Guide

This section introduces almost all the category theory and algebraic abstractions
that the _cats_ library supports.

We will use _Maybe_ for the example snippets, because it has support for all
the abstractions and is very easy to understand. You can read more about it in
the next section of this documentation.


=== Semigroup

A semigroup is an algebraic structure with an associative binary operation
(`mappend`). Most of the builtin collections form a semigroup because their
associative binary operation is analogous to Clojure's `into`.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.builtin])

(m/mappend [1 2 3] [4 5 6])
;; => [1 2 3 4 5 6]
----

Given that the values it contains form a Semigroup, we can `mappend` multiple
_Maybe_ values.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.builtin])
(require '[cats.monad.maybe :as maybe])

(m/mappend (maybe/just [1 2 3])
           (maybe/just [4 5 6]))
;; => #<Just [1 2 3 4 5 6]>
----


=== Monoid

A Monoid is a Semigroup with an identity element (`mempty`). For the collection
types the `mempty` function is analogous to Clojure's `empty`.

Given that the values it contains form a Semigroup, we can `mappend` multiple
_Maybe_, with Nothing being the identity element.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.builtin])
(require '[cats.monad.maybe :as maybe])

(m/mappend (maybe/just [1 2 3])
           (maybe/nothing)
           (maybe/just [4 5 6])
           (maybe/nothing))
;; => #<Just [1 2 3 4 5 6]>
----


=== Functor

Let's dive into the functor. The Functor represents some sort of "computational
context", and the abstraction consists of one unique function: *fmap*.

.Signature of *fmap* function
[source, clojure]
----
(fmap [f fv])
----

The higher-order function *fmap* takes a plain function as the first parameter and
a value wrapped in a functor context as the second parameter. It extracts the
inner value, applies the function to it and returns the result wrapped in same type
as the second parameter.

But what is the *functor context*? It sounds more complex than it is. A Functor
wrapper is any type that acts as "Box" and implements the `Context` and `Functor`
protocols.

.One good example of a functor is the *Maybe* type:
[source, clojure]
----
(require '[cats.monad.maybe :as maybe])

(maybe/just 2)
;; => #<Just 2>
----

The `just` function is a constructor of the Just type that is part of the
Maybe monad.

Let's see one example of using *fmap* over a *just* instance:

.Example using fmap over *just* instance.
[source, clojure]
----
(require '[cats.core :as m])

(m/fmap inc (maybe/just 1))
;; => #<Just 2>
----

The *Maybe* type also has another constructor: `nothing`. It represents the
absence of a value. It is a safe substitute for `nil` and may represent failure.

Let's see what happens if we perform the same operation as the previous example
over a *nothing* instance:

.Example using fmap over *nothing*.
[source, clojure]
----
(m/fmap inc (nothing))
;; => #<Nothing>
----

Oh, awesome, instead of raising a `NullPointerException`, it just returns
*nothing*. Another advantage of using the functor abstraction, is that it
always returns a result of the same type as its second argument.

Let's see an example of applying fmap over a Clojure vector:

.Example using fmap over *vector*.
[source, clojure]
----
(require '[cats.builtin])

(m/fmap inc [1 2 3])
;; => [2 3 4]
----

The main difference compared to the previous example with Clojure's map function,
is that map returns lazy seqs no matter what collection we pass to it:

[source, clojure]
----
(type (map inc [1 2 3]))
;; => clojure.lang.LazySeq (cljs.core/LazySeq in ClojureScript)
----

But why can we pass vectors to the `fmap` function? Because some Clojure container
types like vectors, lists and sets, also implement the functor abstraction. See
the section on built-in types for more information.


=== Applicative

Let's continue with applicative functors. The Applicative Functor represents
some sort of "computational context" like a plain Functor, but with the ability to
execute a function wrapped in the same context.

The Applicative Functor abstraction consists of two functions: *fapply* and
*pure*.

.Signature of *fapply* function
[source, clojure]
----
(fapply [af av])
----

NOTE: the *pure* function will be explained later.

The use case for Applicative Functors is roughly the same as for plain Functors:
safe evaluation of some computation in a context.

Let's see an example to better understand the differences between functor and
applicative functor:

Imagine you have some factory function that, depending on the language, returns a
greeter function, and you only support a few languages.


[source, clojure]
----
(defn make-greeter
  [^String lang]
  (condp = lang
    "es" (fn [name] (str "Hola " name))
    "en" (fn [name] (str "Hello " name))
    nil))
----

Now, before using the resulting greeter you should always defensively check if
the returned greeter is a valid function or a nil value.

Let's convert this factory to use the Maybe type:

[source, clojure]
----
(defn make-greeter
  [^String lang]
  (condp = lang
    "es" (just (fn [name] (str "Hola " name)))
    "en" (just (fn [name] (str "Hello " name)))
    (nothing)))
----

As you can see, this version of the factory differs only slightly from the
original implementation. And this tiny change gives you a new superpower: you
can apply the returned greeter to any value without a defensive nil check:

[source, clojure]
----
(fapply (make-greeter "es") (just "Alex"))
;; => #<Just "Hola Alex">

(fapply (make-greeter "en") (just "Alex"))
;; => #<Just "Hello Alex">

(fapply (make-greeter "it") (just "Alex"))
;; => #<Nothing>
----

Moreover, the applicative functor comes with the *pure* function, which allows
you to put some value in side-effect-free context of the current type.

Examples:

[source, clojure]
----
(require '[cats.monad.maybe :as maybe])

(pure maybe/maybe-monad 5)
;; => #<Just 5>
----

If you do not understand the purpose of the *pure* function, the next sections
should clarify its purpose.


=== Foldable

The *Foldable* is a generic abstraction for data structures that can be folded. It
consists mainly on two functions: `foldl` and `foldr`. `foldl` is also known as
`reduce` or `inject` in other mainstream programming languages.

Both function have an identical signature and differ in how they traverse the
data structure. Let's look at a little example using `foldl`:

[source, clojure]
----
(foldl (fn [acc v] (+ acc v)) 0 [1 2 3 4 5])
;; => 15
----

You can observe that `foldl` is identical to the clojure `reduce` function:

[source, clojure]
----
(reduce (fn [acc v] (+ acc v)) 0 [1 2 3 4 5])
;; => 15
----

And the same operation can be done using `foldr`:

[source, clojure]
----
(foldr (fn [v wc] (+ v wc)) 0 [1 2 3 4 5])
;; => 15
----

The main difference between `foldl` and `reduce` is that `foldl` has a fixed
arity so all parameters are mandatory and `foldl` is a generic abstraction that
can work with other types apart from collections.

As we said previously, the `foldl` and `foldr` differ mainly on how they traverse
the data structure. Then, for understanding better how they work internally,
let's see a graphical representation of the `foldl` execution model:

[source, text]
----
((((acc⊕1)⊕2)⊕3)⊕4)⊕5
----

In contrast to the `foldr` internal execution model that looks like that:

[source, text]
----
1⊕(2⊕(3⊕(4⊕(5⊕(wc)))))
----

In languages with strict argument evaluation, `foldr` does not have many
applications because when the data structure to fold grows it tends to consume
all the stack (causing the well known stack overflow). In case of Clojure,
the unique obvious case of using foldr is for small datastructures.

[source, clojure]
----
(m/foldr #(cons (inc %1) %2) '() (range 100000))
;; => StackOverflowError
----

The *Foldable* abstraction is already implemented for cloure vectors, lazy seqs
and ranges plus the cats maybe, either and validation types. Let see an example
how it behaves with maybe:

[source, clojure]
----
(m/foldl #(m/return (+ %1 %2)) 1 (maybe/just 1))
;; => #<Just 2>

(m/foldl #(m/return (+ %1 %2)) 1 (maybe/nothing))
;; => 1
----

It there also other fold functions that are implemented in terms of the basic
`foldl` or `foldr` that can be *foldm* and *foldmap*. At this moment, cats comes
only with *foldm*.

The *foldm* function in analgous to the `foldl` in terms of how it does the
fold operation, with the difference that is aware of the monad context. Or in
other terms, it works with reducing function that return monad types.

Let see an example:

[source, clojure]
----
(defn m-div
  [x y]
  (if (zero? y)
    (maybe/nothing)
    (maybe/just (/ x y))))

(m/foldm m-div 1 [1 2 3])
;; => #<Just 1/6>


(m/foldm m-div 1 [1 0 3])
;; => #<Nothing>
----


=== Traversable

The *Traversable* is a generic abstraction for data structures that can be
traversed from left to right, running an Applicative action for each element.
Traversables must also be Functors and Foldables.

Note that, since Traversables use the Applicative's `pure` operation, the context
of the applicative must be set when using the `traverse` function.

Let's look at an example: we have a vector with numbers that we want to map to
a Maybe value, and we want to aggregate the result in a Maybe. If any of the
actions fails (is Nothing) the resulting aggregate will be Nothing, but if all
succeed we preserve the vector's structure inside a Just value.

First of all, we define the function that will transform a number to a Maybe.
Our function will wrap the value in a Just if it's even and in a Nothing if it's
not:

[source, clojure]
----
(require '[cats.monad.maybe :as maybe])

(defn just-if-even
  [n]
  (if (even? n)
    (maybe/just n)
    (maybe/nothing)))
----

Now that we have a function that maps a value to the Maybe Applicative, we can
traverse a vector of numbers and aggregate a Maybe value. The applicatives will
be evaluated from left to right using the applicative's `fapply`.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.context :as ctx])

(ctx/with-context maybe/context
  (m/traverse just-if-even []))
;; => #<Just []>

(ctx/with-context maybe/context
  (m/traverse just-if-even [2 4]))
;; => #<Just [2 4]>

(ctx/with-context maybe/context
  (m/traverse just-if-even [1 2]))
;; => #<Nothing>

(ctx/with-context maybe/context
  (m/traverse just-if-even [2 3]))
;; => #<Nothing>
----

Maybe is not that much of an interesting applicative, let's see an example of
using the Validation applicative to validate a vector of values aggregating
the results, be them success or failure.

First we will define a validation function that, given a number, will succed if
it's even. If it's odd, it will fail and record the failure in the map monoid
from value to the error type (`:not-even`).

[source, clojure]
----
(require '[cats.applicative.validation :as v])

(defn valid-if-even
  [n]
  (if (even? n)
    (v/ok n)
    (v/fail {n :not-even})))
----

Now let's try it with some vectors to see how failures are aggregated:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.context :as ctx])

(ctx/with-context v/context
  (m/traverse valid-if-even []))
;; => #<Ok []>

(ctx/with-context v/context
  (m/traverse valid-if-even [2 4]))
;; => #<Ok [2 4]>

(ctx/with-context v/context
  (m/traverse valid-if-even [1 2]))
;; => #<Fail {1 :not-even}>

(ctx/with-context v/context
  (m/traverse valid-if-even [2 3 4 5]))
;; => #<Fail {3 :not-even, 5 :not-even}>
----


=== Monad

Monads are the most discussed programming concept to come from category theory.
Like functors and applicatives, monads deal with data in contexts.

Additionally, monads can also transform contexts by unwrapping data, applying
functions to it and putting new values in a completely different context.

The monad abstraction consists of two functions: *bind* and *return*

.Bind function signature.
[source,clojure]
----
(bind [mv f])
----

As you can see, bind works much like a Functor but with inverted arguments. The
main difference is that in a monad, the function is responsible for wrapping a
returned value in a context.

.Example usage of the bind higher-order function.
[source,clojure]
----
(m/bind (maybe/just 1)
        (fn [v] (maybe/just (inc v))))
;; => #<Just 2>
----

One of the key features of the bind function is that any computation executed
within the context of bind (monad) knows the context type implicitly. With this,
if you apply some computation over some monadic value and you want to return
the result in the same container context but don't know what that container is,
you can use `return` or `pure` functions:

.Usage of return function in bind context.
[source,clojure]
----
(m/bind (maybe/just 1)
        (fn [v]
          (m/return (inc v))))
;; => #<Just 2>
----

The `return` or `pure` functions, when called with one argument, try to use
the dynamic scope context value that's set internally by the `bind` function.
Therefore, you can't use them with one argument outside of a `bind` context.

We now can compose any number of computations using monad *bind*
functions. But observe what happens when the number of computations increases:

.Composability example of bind function.
[source, clojure]
----
(m/bind (maybe/just 1)
        (fn [a]
          (m/bind (maybe/just (inc a))
                  (fn [b]
                    (m/return (* b 2))))))
----

This can quickly lead to callback hell. To solve this, _cats_ comes with a powerful
macro: *mlet*

.Previous example but using *mlet* macro.
[source, clojure]
----
(m/mlet [a (maybe/just 1)
         b (maybe/just (inc a))]
  (m/return (* b 2)))
----


=== MonadZero

Some monads also have the notion of an identity element analogous to that of
Monoid. When calling `bind` on a identity element for a monad, the same value is
returned. This means that whenever we encounter the identity element in a monadic
composition it will short-circuit.

For the already familiar Maybe type the identity element is Nothing:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/mzero maybe/maybe-monad)
;; => #<Nothing>
----

Having an identity element we can make a monadic composition short-circuit using
a predicate:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/bind (maybe/just 1)
        (fn [a]
          (m/bind (if (= a 2)
                    (m/return nil)
                    (m/mzero))
                  (fn [_]
                    (m/return (* a 2))))))
;; => #<Nothing>
----

As you can see in the above example the predicate `(= a 2)` returns either a
monadic value `(m/return nil)` or the identity value for the maybe monad. This
can be captured in a function, which is available in `cats.core` namespace:

[source, clojure]
----
(defn guard
  [b]
  (if b
    (return nil)
    (mzero)))
----

The above example could be rewritten as:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/bind (maybe/just 1)
        (fn [a]
          (m/bind (m/guard (= a 2))
                  (fn [_]
                    (m/return (* a 2))))))
;; => #<Nothing>
----

Or, using mlet:


[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/mlet [a (maybe/just 1)
         :when (= a 2)]
   (m/return (* a 2)))
;; => #<Nothing>
----


=== MonadPlus

MonadPlus is a complementary abstraction for Monads that support an associative
binary operation, analogous to that of a Semigroup. If the monad implements the
MonadZero and MonadPlus protocols it forms a monoid.

For the Maybe type, `mplus` acts similarly to a logical OR that treats `Nothing`
values as falsey.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/mplus (maybe/nothing))
;; => #<Nothing>

(m/mplus (maybe/nothing) (maybe/just 1))
;; => #<Just 1>

(m/mplus (maybe/just 1) (maybe/just 2))
;; => #<Just 1>
----


=== Monad Transformers

==== Motivation

We can combine two functors and get a new one automatically. Given any two
functors _a_ and _b_, we can implement a generic `fmap` for the type _a (b Any)_,
we'll call it fmap2:

[source, clojure]
----
(ns functor.example
  (:require [cats.core :refer [fmap]]
            [cats.builtin]
            [cats.monad.maybe :refer [just]]))

(defn fmap2
  [f fv]
  (fmap (partial fmap f) fv))

; Here, 'a' is [] and 'b' is Maybe, so the type of the
; combined functor is a vector of Maybe values that could
; contain a value of any type.
(fmap2 inc [(maybe/just 1) (maybe/just 2)])
;; => [#<Just 2> #<Just 3>]
----

However, monads don't compose as nicely as functors do. We have to actually
implement the composition ourselves.

In some circumstances we would like combine the effects of two monads into
another one. We call the resulting monad a monad transformer, which is the
composition of a "base" and "inner" monad. A monad transformer is itself a monad.


==== Using monad transformers

Let's combine the effects of two monads: State and Maybe. We'll create the
transformer using State as the base monad since we want the resulting type to
be a stateful computation that may fail: `s -> Maybe (a, s)`.

Almost every monad implemented in _cats_ has a monad transformer for combining
it with any other monad. The transformer functions take a Monad as their
argument and they return a reified MonadTrans:

[source, clojure]
----
(ns transformers.example
  (:require [cats.core :as m]
            [cats.context :as ctx]
            [cats.monad.maybe :as maybe]
            [cats.labs.state :as state]))

(def maybe-state
  (state/state-transformer maybe/context))

(ctx/with-context maybe-state
  (state/run-state (m/return 42) {}))
;; => #<Just #<Pair [42 {}]>>
----

As we can see in the example below, the return of the `maybe-state` monad creates
a stateful function that yields a Maybe containing a pair (value, next state).

You probably noticed that we had to wrap the state function invocation with
`cats.context/with-context`. When working with monad transformers, we have to
be explicit about what monad we are using to implement the binding policy since
there is no way to distinguish values from a transformer type from those of
a regular monad.

The `maybe-state` monad combines the semantics of both State and Maybe.


== Types

This section will take a tour over the types exposed in cats library and explain
how they can be used in the previously explained abstractions.


=== Maybe

This is one of the two most used monad types (also known as Optional in other
programming languages).

The Maybe monad represents encapsulation of an optional value; e.g. it is used
as the return type of functions which may or may not return a meaningful value
when they are applied. It consists of either an empty constructor (called None
or Nothing), or a constructor encapsulating the original data type A (e.g.
Just A or Some A).

_cats_, implements two types:

- `Just` that represents a value in a context.
- `Nothing` that represents the abscense of value.

.Example creating instances of `Just` and `Nothing` types:
[source, clojure]
----
(maybe/just 1)
;; => #<Just 1>

(maybe/nothing)
;; => #<Nothing>
----

There are other useful functions for working with maybe monad types in the same
namespace. See the API documentation for a full list of them. But here we will
explain a little relevant subset of them.

We mentioned above that *fmap* extracts the value from a functor context. You
will also want to extract values wrapped by *just* and you can do that with
*from-maybe*.

As we said previously, the Just or Nothing instances act like wrappers and
in some circumstances you will want extract the plain value from them. cats offers
the `from-maybe` function for that.

.Example using *from-maybe* to extract values wrapped by *just*.
[source, clojure]
----
(maybe/from-maybe (maybe/just 1))
;; => 1

(maybe/from-maybe (maybe/nothing))
;; => nil

(maybe/from-maybe (maybe/nothing) 42)
;; => 42
----

The `from-maybe` function is a specialized version of a more generic one:
`cats.core/extract`. The generic version is a polymorphic function and will
also work with different types of different monads.

For interoperability with Clojure and ClojureScript's `IDeref` abstraction,
maybe values are derrefable.

.Example using *deref* to extract values wrapped by *just*.
[source, clojure]
----
(deref (maybe/just 1))
;; => 1

(deref (maybe/nothing))
;; => nil
----


=== Either

Either is another type that represents a result of a computation, but (in
contrast with maybe) it can return some data with a failed computation result.

In _cats_ it has two constructors:

- `(left v)`: represents a failure.
- `(right v)`: represents a successful result.

.Usage example of *Either* constructors.
[source, clojure]
----
(require '[cats.monad.either :refer :all])

(right :valid-value)
;; => #<Right [:valid-value :right]>

(left "Error message")
;; => #<Either [Error message :left]>
----

NOTE: Either is also (like Maybe) a Functor, Applicative Functor and Monad.

Like Maybe, Either values can be dereferenced returning the value they contain.


=== Exception

Also known as the Try monad, as popularized by Scala.

It represents a computation that may either result in an exception or return
a successfully computed value. Is very similar to the Either monad, but is
semantically different.

It consists of two types: Success and Failure. The Success type is a simple
wrapper, like Right of the Either monad. But the Failure type is slightly different
from Left, because it always wraps an instance of Throwable (or any value in
cljs since you can throw arbitrary values in the JavaScript host).

The most common use case of this monad is to wrap third party libraries that
use standard Exception based error handling. Under normal circumstances,
however, you should use Either instead.

It is an analogue of the try-catch block: it replaces try-catch's stack-based
error handling with heap-based error handling. Instead of having an exception
thrown and having to deal with it immediately in the same thread, it disconnects
the error handling and recovery.

.Usage example of *try-on* macro.
[source, clojure]
----
(require '[cats.monad.exception :as exc])

(exc/try-on 1)
;; => #<Success [1]>

(exc/try-on (+ 1 nil))
;; => #<Failure [#<NullPointerException java.lang.NullPointerException>]>
----

_cats_ comes with other syntactic sugar macros: `try-or-else` that returns a
default value if a computation fails, and `try-or-recover` that lets you handle
the return value when executing a function with the exception as first parameter.

.Usage example of `try-or-else` macro.
[source, clojure]
----
(exc/try-or-else (+ 1 nil) 2)
;; => #<Success [2]>
----

.Usage example of `try-or-recover` macro.
[source, clojure]
----
(exc/try-or-recover (+ 1 nil)
                    (fn [e]
                      (cond
                        (instance? NullPointerException e) 0
                        :else 100)))
;; => #<Success [0]>
----

The types defined for the Exception monad (Success and Failure) also implement
the Clojure IDeref interface, which allows library development using monadic
composition without forcing a user of that library to use or understand monads.

That is because when you dereference the failure instance, it will reraise the
enclosed exception.

.Example dereferencing a failure instance
[source, clojure]
----
(def f (exc/try-on (+ 1 nil)))

@f
;; => NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
----


=== Validation

The validation type is similar to the Either or Exception types except that it
doesn't implement a Monad instance. It has two constructors: `ok` and `fail`,
representing success and failure respectively.

[source, clojure]
----
(require '[cats.applicative.validation :as v])
(require '[cats.core :as m])

(v/ok 42)
;; => #<Ok 42>

(v/fail [])
;; => #<Fail []>
----

It implements the Applicative protocol, and its intended usage is as an
Applicative. Applying Validation values together errs on the side of the failure,
and applying failures together aggregates their values using the Semigroup's
`mappend` function.

[source, clojure]
----
(require '[cats.applicative.validation :as v])
(require '[cats.core :as m])

(m/fapply (v/ok 42) (v/fail "OH NOES"))
;; => #<Fail "OH NOES">

;; Note that `<*>` is a variadic fapply
(m/<*> (v/ok 42)
       (v/fail {:foo "bar"})
       (v/fail {:baz "fubar"})
       (v/ok 99))
;; => #<Fail {:baz "fubar", :foo "bar"}>
----


=== Built in types

Some of the abstractions in _cats_ are implemented for built-in types but you
can't use them directly. First, you must load the `cats.builtin` namespace:

[source, clojure]
----
(require '[cats.builtin])
(require '[cats.core :as m])

(m/fmap inc [1 2 3 4])
;; => [2 3 4 5]
----


==== nil

Given the fact that `nil` is both a value and a type, we have extended the `nil`
type to be equivalent to Maybe monad's `Nothing`. This means that you can use
`nil` as if were a `Just` instance like in the following example:

[source, clojure]
----
(use 'cats.builtin)
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/mlet [x (maybe/just 42)
         y nil]
  (m/return (+ x y)))
;; => nil
----

As you can see, the `mlet` short-circuits when encountering a `nil` value.


==== Vector

Clojure vectors also participate in several of the abstractions implemented
in _cats_, most notably as a monad. Compare the following `for` comprehension:

[source, clojure]
----
(for [x [1 2]
      y [3 4 5]]
   (+ x y))
;; => (4 5 6 5 6 7)
----

with the equivalent using _mlet_:

[source, clojure]
----
(use 'cats.builtin)
(require '[cats.core :as m])

(m/mlet [x [1 2]
         y [3 4 5]]
  (m/return (+ x y)))
;; => [4 5 6 5 6 7]
----

Note the symmetry between `for` and `mlet`. This is not accidental, both are
what is called a monad comprehension, the difference is that `for` is limited to
sequences and `mlet` can work with arbitrary monads.

Also, since `mlet` desugars into calls to the Monad's `bind` function, its result
keeps the type of the monadic values.


==== Lazy sequences

Lazy sequences implement the same abstractions as vectors with practically an
identical implementation. If you don't need the results right away or are
interested in a subset of the final results, you can use lazy sequence
comprehensions.

Using `mlet` with lazy sequences yields exactly the same result as using `for`:

[source, clojure]
----
(use 'cats.builtin)
(require '[cats.core :as m])

(m/mlet [x (lazy-seq [1 2])
         y (lazy-seq [3 4 5])]
  (m/return (+ x y)))
;; => (4 5 6 5 6 7)
----


==== Set

Sets implement almost every abstraction in _cats_, from Semigroup to Monad.

[source, clojure]
----
(use 'cats.builtin)
(require '[cats.core :as m])

(m/pure set-monad 42)
;; => #{42}

(m/fmap inc #{1 2 3 4})
;; => #{4 3 2 5}

(m/bind #{1 2 3}
        (fn [v] #{v (inc v)}))
;; => #{1 4 3 2}
----


==== Map

Maps implement the _Semigroup_ protocol, since we can use `merge` as their
associative binary operation. Using `mappend` on maps is a way to merge them
together:

[source, clojure]
----
(use 'cats.builtin)
(require '[cats.core :as m])

(m/mappend {:a "A"} {:b "B"})
;; => {:a "A", :b "B"}
----

Since we can consider the empty map an identity element for the `mappend`
associative binary operation maps also implement _Monoid_ and the `mempty`
function gives an empty map.


== Syntax sugar

Additionally to the abstractions and types, *cats* exposes some powerfull
syntax abstractions that surelly will make the usage of that abstractions
in a more familiar way.


=== mlet

The `mlet` syntactic abstraction intends to facilitate the composition
of monadic operations.

If you've followed along with the documentation you've seen many examples
of its usage already, let's see what can `mlet` do. First of all, mlet turns
this let-like bindings:

[source, clojure]
----
(m/mlet [a (maybe/just 1)
         b (maybe/just (inc a))]
  (m/return (* a b)))
----

into a chain of calls to bind:

[source, clojure]
----
(m/bind (maybe/just 1)
        (fn [a]
          (m/bind (maybe/just (inc a))
                  (fn [b]
                    (m/return (* a b))))))
----

That makes a lot more natural to write code that uses monads and gives a very
familiar `let` like syntax abstraction that makes the clojure code that uses
monads less "strange".

If you are coming from Haskell, mlet is mostly analogous to the *do notation*.

Since the bindings in the mlet macro run the monadic effects of the right-hand
values we cannot just put any value in there and expect to be bound to its
left symbol. For cases where we want the regular behavior of let we can inline
a `:let` clause, just like with Clojure's `for`:

[source, clojure]
----
(m/mlet [a (maybe/just 1)
         b (maybe/just (inc a))
         :let [z (+ a b)]]
  (m/return (* z 2)))
----

`mlet` has support for using guards using a `:when` clause, analogous to the
one used in `for`. We can filter out values using `bind` with `mlet` and
`:when` like the following:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :as maybe])

(m/mlet [a (maybe/just 1)
         :when (= a 2)]
   (m/return (* a 2)))
;; => #<Nothing>
----

Any monadic type that implements `MonadZero` can be combined with guards
inside `mlet` bindings. Here is an example with vectors:

[source, clojure]
----
(require '[cats.builtin]
(require '[cats.core :as m])

(m/mlet [a [1 2 3 4]
         :when (odd? a)]
   (m/return (* a 2)))
;; => [2 6]
----


=== alet

One limitation of monadic bind is that all the steps are strictly sequential and
happen one at a time. This piece of code illustrates the usage of monadic bind:

[source, clojure]
----
(require '[cats.core :refer [bind return]])
(require '[cats.monad.maybe :refer [just]])

(bind (just 1)
      (fn [a]
        (bind (just 41)
              (fn [b]
                (return (+ a b))))))
;; => #<Just 42>
----

In the first call to `bind`, `(just 1)` and the anonymous function will be
evaluated. The call of the anonymous function performed by the first `bind`
will cause the evaluation of the `(just 41)` and the next anonymous function,
which will be also called to create the final result. Note that `(just 1)`
and `(just 41)` are independent and thus could be evaluated at the same time.

Here is the `mlet` version for reference and clarity:

[source, clojure]
----
(mlet [a (just 1)
       b (just 41)]
  (return (+ a b)))
;; => #<Just 42>
----

Now let's see the equivalent using `alet`:

[source, clojure]
----
(require '[cats.core :refer [alet]])

(alet [a (just 1)
       b (just 41)]
  (+ a b))
;; => #<Just 42>
----

Note that no `return` is used, this is because the `alet` body runs inside
the applicative context with `fapply`. This is roughly what `alet` desugars to:

[source, clojure]
----
(fapply (fn [a]
           (fn [b]
             (do
               (+ a b))))
         (just 1)
         (just 41))
;; => #<Just 42>
----

Note that now `(just 1)` and `(just 41)` are evaluated at the same time. This
use of `fapply` can be called "applicative bind" and in some cases is more
efficient than monadic bind. Furthermore, the `alet` macro splits the bindings
into batches that have dependencies only in previous values and evaluates all
applicative values in the batch at the same time.

This makes no difference at all for Maybe, but applicatives that have latency
in their calculations (for example promises that do an async computation) get
a pretty good evaluation strategy, which can minimize overall latency. In the
next examples we use the link:https://github.com/funcool/promesa[promesa]
clj/cljs library for emulate asynchronous behavior:

[source, clojure]
----
(require '[cats.core :as m])
(require '[promesa.core :as p])

(defn sleep-promise
  "A simple function that emulates an
  asynchronous operation."
  [wait]
  (p/promise (fn [resolve reject]
               (future
                 (Thread/sleep wait)
                 (resolve wait)))))

;; note: deref-ing for blocking the current thread
;; waiting for the promise being delivered

(time
 @(m/mlet [x (sleep-promise 42)
           y (sleep-promise 41)]
    (m/return (+ x y))))
;; "Elapsed time: 84.328182 msecs"
;; => 83

(time
 @(m/alet [x (sleep-promise 42)
           y (sleep-promise 41)]
    (+ x y)))
;; "Elapsed time: 44.246427 msecs"
;; => 83
----

Another example for illustrating dependencies between batches:

[source, clojure]
----
(time
 @(m/mlet [x (sleep-promise 42)
           y (sleep-promise 41)
           z (sleep-promise (inc x))
           a (sleep-promise (inc y))]
   (m/return  (+ z a))))
;; "Elapsed time: 194.253182 msecs"
;; => 85

(time
 @(m/alet [x (sleep-promise 42)
           y (sleep-promise 41)
           z (sleep-promise (inc x))
           a (sleep-promise (inc y))]
    (+ z a)))
;; "Elapsed time: 86.20699 msecs"
;; => 85
----


== Higher-order functions

=== curry

The first combinator that _cats_ provides is a `curry` macro. Given a function,
it can convert it to a curried versions of itself. The generated function will
accept parameters until all the expected parameters are given.

Let's see some examples of a curried function in action:

[source, clojure]
----
(require '[cats.core :as m])

(defn add [a b c]
  (+ a b c))

(def curried-add (m/curry add))

(= curried-add (curried-add))
;; => true

(= (curried-add 1 2 3) 6)
;; => true

(= ((curried-add 1) 2 3) 6)
;; => true

(= ((curried-add 1 2) 3) 6)
;; => true
----

As you can see above, since the original `add` has a single arity (3) and is
fixed (i.e. it doesn't accept a variable number of arguments), the `curry` macro
was able to generate a curried function with the correct number of parameters.

This doesn't mean that functions with multiple arities or variadic arguments
can't be curried but an arity for the curried function must be given:

[source, clojure]
----
(require '[cats.core :as m])

(def curried+ (m/curry 3 +))

(= curried+ (curried+))
;; => true

(= (curried+ 1 2 3) 6)
;; => true

(= ((curried+ 1) 2 3) 6)
;; => true

(= ((curried+ 1 2) 3) 6)
;; => true
----

Curried functions are very useful in combination with the applicative's
`fapply` operation, since we can curry a function and use applicatives for
building up results with context-specific effects.

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :refer [just nothing]])

(def curried+ (m/curry 3 +))

(m/fapply (just curried+) (just 1) (just 2) (just 3))
;; => #<Just 6>

(m/fapply (just curried+) (just 1) (just 2) (nothing))
;; => #<Nothing>

(m/fapply (just curried+) (just 1) nil (just 3))
;; => nil

(m/fapply (m/fmap curried+ (just 1)) (just 2) (just 3))
;; => #<Just 6>

(m/<*> (m/<$> curried+ (just 1)) (just 2) (just 3))
;; => #<Just 6>
----


=== lift-m

The `lift-m` macro is a combinator for promoting functions that work on
regular values to work on monadic values instead. It uses the monad's bind
operation under the hood and, like `curry`, can be used without specifying arity
if the function we are lifting has a fixed and a single arity:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :refer [just nothing]])

(defn add [a b c]
  (+ a b c))

(def add-m (m/lift-m add))

(add-m (just 1) (just 2) (just 3))
;; => #<Just 6>

(add-m (just 1) (nothing) (just 3))
; => #<Nothing>

(add-m (just 1) nil (just 3))
;; => nil
----

Like with `curry`, we must provide an arity in case we are lifting a function
that has multiple arities or is variadic:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :refer [just nothing]])

(def add-m (m/lift-m 3 +))

(add-m (just 1) (just 2) (just 3))
;; => #<Just 6>

(add-m (just 1) (nothing) (just 3))
; => #<Nothing>

(add-m (just 1) nil (just 3))
;; => nil
----

Note that you can combine both `curry` and `lift-m` to get curried functions
that work on monadic types using the `curry-lift-m` macro. The arity is
mandatory when using this macro:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.monad.maybe :refer [just nothing]])

(def curried-add-m (m/curry-lift-m 3 +))

(curried-add-m (just 1) (just 2) (just 3))
;; => #<Just 6>

((curried-add-m (just 1)) (just 2) (just 3))
;; => #<Just 6>

((curried-add-m (just 1) (just 2)) (just 3))
;; => #<Just 6>
----


== Labs

This section intends to explain different kind of extra features that can be
found under *cats.labs* namespace. The fact that they are here because they
are experimental, requires external dependencies or simply does not have much
application in clojure(script).

In any case the state of each module will be notified on the start of the
each section.


=== test.check

*Status:* Experimental

The `cats.labs.test` namespace implements monad and applicative instances for
generators, which lets you use the `cats.core/alet` and `cats.core/mlet` macros
for writing generators:

[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.labs.test])
(require '[clojure.test.check.generators :as gen])

(def color
  (m/alet [r gen/int
           g gen/int
           b gen/int]
    [r g b]))

(gen/sample color 1)
;; => ([0 0 0])

(def mcolor
  (m/mlet [r gen/int
           g gen/int
           b gen/int]
    (m/return [r g b])))

(gen/sample mcolor 1)
;; => ([0 0 0])
----

Apart from that, the namespace contains multiple functions for generating test.check
properties that verify the laws of Semigroup, Monoid, Functor, Applicative, Monad,
MonadZero and MonadPlus.

The implementation of cats' abstractions are tested using generative testing and
the `cats.labs.test` property generation functions.


=== Channel

*Status:* Experimental

This namespace exposes the ability to use the *core.async* channel as monadic
type and in consequence use it in `mlet` or `alet` macros.

Before use it, you should add core.async to your dependencies:

[source, clojure]
----
[org.clojure/core.async "0.2.374"]
----

Now, let see some code. This will allow you understand how it can be used and
why this integration between cats and core.async matters. At first step we will
go to define a function that emulates whatever asynchronous task, that for
our case it's consist in a just sleep operation:

[source, clojure]
----
(require '[clojure.core.async :as a])
(require '[cats.labs.channel])

(defn async-call
  "A function that emulates some asynchronous call."
  [n]
  (a/go
    (println "---> sending request" n)
    (a/<! (a/timeout n))
    (println "<--- receiving request" n)
    n))
----

Now, instead of using the `go` macro, just use a `let` like bindings with the
help of the *mlet* macro for bind values to asyncrhonous calls:

[source, clojure]
----
(time
 (<!! (m/mlet [x (async-call 200)
               y (async-call 100)]
        (m/return (+ x y)))))
;; ---> sending request 200
;; <--- receiving request 200
;; ---> sending request 100
;; <--- receiving request 100
;; "Elapsed time: 202.236804 msecs"
;; => 200
----

Here we can observe few things:

* The asynchronous calls are made serially.
* We are calling a function that return a channel and bind its value to a symbol.
* At the end, an operation is performed with the `mlet` bindings.
* The `mlet` macro also returns a channel.

The main difference with the default clojure `let`, is that the bindings
are already plain values (not channels). The take! operation is already
performed automatically by the `mlet`. This kind of behavior will make you
fully asynchronous code looks like synchronous code.

But, cats also comes with `alet` that has identical aspect to the previously
used `mlet` macro, but it has some advantages over it. Let see an example:

[source, clojure]
----
(time
  (a/<!! (m/alet [x (async-call 100)
                  y (async-call 100)]
            (+ x y)))))

;; ---> sending request 100
;; ---> sending request 100
;; <--- receiving request 100
;; <--- receiving request 100
;; "Elapsed time: 101.06644 msecs"
;; => 200
----

And here we can observe few things:

* The asynchronous calls are made in parallel.
* The total time of processing is half less of if we use `mlet`.
* The `return` function is not used because `alet` evaluates the body in the context
  of the applicative.

The alet is a powerfull macro that analyzes the dependencies between bindings
and executes the expressions in batches resultin in a very atractive feature
for asynchronous calls.

Here an other examples that shows in a clearly way how the batches are executed:

[source, clojure]
----
(time
 (a/<!! (m/alet [x (async-call 120)
                 y (async-call 130)
                 z (async-call (- x 100))
                 u (async-call (- y 100))
                 t (async-call (inc u))]
          z))))
;; ---> sending request  130
;; ---> sending request  120
;; <--- receiving request  120
;; <--- receiving request  130
;; ---> sending request  20
;; ---> sending request  30
;; <--- receiving request  20
;; <--- receiving request  30
;; ---> sending request  31
;; <--- receiving request  31
;; "Elapsed time: 194.536235 msecs"
;; => 20
----


=== Manifold Deferred

*Status:* Experimental

This namespace exposes the ability to use the *manifold* deferred as monadic
type and in consequence use it in `mlet` or `alet` macros.

Before use it, you should add manifold to your dependencies:

[source, clojure]
----
[manifold "0.1.1"]
----

Now, let see some code. This will allow you understand how it can be used
and why this integration between cats and manifold matters. At first step we
will go to define a function that emulates whatever asynchronous task, that for
our case it's consist in a just sleep operation:

For demostration purposes, let's define a function that emulates the asyncrhonous
call:

[source, clojure]
----
(require '[cats.labs.manifold :as mf]
         '[manifold.deferred :as d])

(defn async-call
  "A function that emulates some asynchronous call."
  [n]
  (d/future
    (println "---> sending request" n)
    (Thread/sleep n)
    (println "<--- receiving request" n)
    n))
----

Now, the manifold deferreds can participate in the monad/applicative abstractions
using `mlet` and `alet` respectivelly.

.Example using manifold deferred with `mlet`.
[source, clojure]
----
(time
  @(m/mlet [x (async-call 200)
            y (async-call 100)]
     (m/return (+ x y)))))
;; ---> sending request 200
;; <--- receiving request 200
;; ---> sending request 100
;; <--- receiving request 100
;; "Elapsed time: 202.236804 msecs"
;; => 200
----


If you are familiar with manifold's `let-flow` macro, the cats `alet` serves
for almost identical purpose, with difference that `alet` is defined as
generic abstraction instread of a specific purpose macro.

.Example using manifold deferred with `alet`.
[source, clojure]
----
(time
  @(m/alet [x (async-call 100)
            y (async-call 100)]
     (+ x y)))))

;; ---> sending request 100
;; ---> sending request 100
;; <--- receiving request 100
;; <--- receiving request 100
;; "Elapsed time: 101.06644 msecs"
;; => 200
----


=== State

*Status:* Experimental

The State monad is one of the special cases of monads most commonly used in
Haskell. It has several purposes including: lazy computation, composition, and
maintaining state without explicitly passing it to every function manualy.

The de-facto monadic type of the state monad is a plain function. A function
represents a computation as is (without executing it). Obviously, a function
should have some special characteristics to work in monad state composition.

.Valid function for the state monad
[source, clojure]
----
(fn [state]
  "Takes a state as argument and returns a vector
  with the first element being the processed value and
  the second element being the new transformed state."
  (let [newvalue (first state)
        newstate (next state)]
    [newvalue newstate]))
----

You just saw an example of the low-level primitive state monad. For basic usage
you do not need to write your own functions, just use some helpers that _cats_
provides.

Let's look at one example before explaining the details:

.Lazy composition of computations
[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.labs.state :as st])

(m/mlet [state (st/get-state)
         _     (st/put-state (next state))]
  (m/return (first state)))
;; => #<State cats.labs.state.State@2eebabb6>
----

At the moment of evaluation in the previous expression, nothing of what we
have defined is executed. But instead of returning the unadorned final value
of the computation, a strange/unknown object of type *State* is returned.

The State type is simply a wrapper for Clojure functions, nothing more.

Now, it's time to execute the composed computation. We can use one of the following
functions exposed by _cats_ for that: `run-state`, `eval-state` and `exec-state`.

- `run-state` executes the composed computation and returns both the value and the
  final state.
- `eval-state` executes the composed computation and returns the resulting
  value, discarding the state.
- `exec-state` executes the composed computation and returns only the resulting
  state, ignoring the resulting value.

.Example of resuls of using the previosly listed functions
[source, clojure]
----
(m/run-state s [1 2 3])
;; => #<Pair [1 (2 3)]>

(m/eval-state s [1 2 3])
;; => 1

(m/exec-state s [1 2 3])
;; => (2 3)
----

The `run-state` function returns an instance of the Pair type. The Pair type
acts like any other seq in Clojure with the exception that it can only contain
two values.


=== Reader

*Status:* Experimental

The reader monad is another commonly used monad in Haskell. It's used for
gluing together computations that depend on a read-only environment. As with
the state monad, we don't have to thread the environment manualy since the
monadic bind does it for us. The type of the reader monad are one-argument
functions.

The Reader type is analogous to State, simply a wrapper for regular Clojure
functions. If we want our functions to participate in the reader abstraction
we have to wrap them in a Reader instance.

.Valid function for the reader monad
[source, clojure]
----
(require '[cats.labs.reader :as r])

(def start-server
  (r/reader
    (fn [env]
      "Takes an environment with options as an argument and runs a web
       server in the address specified by `:host` and `:port`."
      (run-http-server (:host env) (:port env)))))
----

cats provides a few reader functions already. `ask` is the simplest reader,
simply returns the environment. We can execute readers using the `run-reader`
function which accepts a reader and an environment.

.Example of running the ask reader
[source, clojure]
----
(require '[cats.labs.reader :as r])

(r/run-reader r/ask [1 2 3])
;; => [1 2 3]
----

Let's use `mlet` for building new readers out of existing ones:

.Example of composing reader computations
[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.labs.reader :as r])

(m/mlet [env r/ask]
  (m/return (inc env)))
;; => #<Reader cats.labs.reader.Reader@2eebabb6>
----

We can then run it using `run-reader`:

.Example of composing reader computations
[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.labs.reader :as r])

(r/run-reader (m/mlet [env r/ask]
                (m/return (inc env)))
              41)
;; => 42
----

We can also alter the reader's environment in a context using the `local`
function which given a function and a reader returns a new reader whose
environment is the result of applying the first function given to `local` to
the original environment. Let's see it in action to understand it better:

.Example of composing reader computations
[source, clojure]
----
(require '[cats.core :as m])
(require '[cats.labs.reader :as r])

(r/run-reader (m/mlet [env (r/local #(* 2 %) r/ask)]
                (m/return (+ env 2)))
              20)
;; => 42
----

Note that since we executed `ask` with the function `#(*2 %)` altering its
original environment (20), the resulting `env` value is two times the original
environment.


=== Writer

*Status:* Experimental


TODO
////
The writer monad comes from Haskell too. It's used for accumulating a log
together with the values generated by computations. As with the state and
reader monads, we don't have to explicitly thread the log manually since
the monadic bind takes care of that. The type
////


=== Continuation

*Status:* Experimental

TODO


=== Lens

*Status:* Stable

Implementation of functional references to one value modeled as functions. Is
a generalization of get and put mapping to the particular part of a data
structure.


==== First steps

We'll start by using the most basic lens, the identity lens. We can get the value
a lens is focused on using the `focus` function in `cats.labs.lens` ns:

[source, clojure]
----
(require '[cats.labs.lens :as l])

(l/focus l/id [0 1 2 3])
;; => [0 1 2 3]
----

We have two other primitives available: the `put` operation and `over`, which lets
us apply a function over the focused value of a lens:

[source, clojure]
----
(l/put l/id 42 [0 1 2 3])
;; => 42

(l/over l/id count [0 1 2 3])
;; => 4
----

There are some builtin lenses that can be used out of the box such as `fst`, `snd`
and `nth`. Let see some examples on how them can be used:

.Example using `fst` lense
[source, clojure]
----
;; Focus over the first element of a vector
(l/focus l/fst [1 2 3])
;; => 1

;; Apply a function over first element of a vector
(l/over l/fst inc [1 2 3])
;; => [2 2 3]

;; Replace the first value of an element of a vector
(l/put l/fst 42 [1 2 3])
;; => [42 2 3]
----

.Example using the `nth` lense
[source, clojure]
----
(l/focus (l/nth 2) [1 2 3])
;; => 3

(l/over (l/nth 2) inc [1 2 3])
;; => [1 2 4]

(l/put (l/nth 2) 42 [1 2 3])
;; => [1 2 42]
----


==== Lenses composition

One of the big advantatges of the lenses implementation of cats library is that
them are implemented using plain functions:

[source, clojure]
----
(def my-lens (comp l/fst l/fst (l/nth 2)))

(def data
  [[0 1 2]
   [3 4 5]])

(l/focus my-lens data)
;; => 2

(l/put my-lens 42 data)
;; => [[0 1 42] [3 4 5]]
----

Lenses compose with regular function composition and, like transducers, the
combined lens runs from left to right.


==== Builtin lenses

There's `key` and `select-keys` for focusing on one or multiple keys respectively:

.Example focusing in a specific key/keys of associative data structure
[source, clojure]
----
(l/focus (l/key :a) {:a 1 :b 2})
;; => 1

(l/over (l/key :a) str {:a 1 :b 2})
;; => {:a "1", :b 2}

(l/put (l/key :a) 42 {:a 1 :b 2})
;; => {:a 42, :b 2}

(l/focus (l/select-keys [:a]) {:a 1 :b 2})
;; => {:a 1}

(l/over (l/select-keys [:a :c])
        (fn [m]
         (zipmap (keys m) (repeat 42)))
        {:a 1 :b 2})
;; => {:b 2, :a 42}

(l/put (l/select-keys [:a :c])
       {:a 0}
       {:a 1 :b 2 :c 42})
;; => {:b 2, :a 0}
----

`in` for focusing on a path:

.Example focusing in neest data structures
[source, clojure]
----
(l/focus (l/in [:a :b])
         {:a {:b {:c 42}}})
;; => {:c 42}

(l/over (l/in [:a :b]) #(zipmap (vals %) (keys %))
        {:a {:b {:c 42}}})
;; => {:a {:b {42 :c}}}

(l/put (l/in [:a :b])
       42
       {:a {:b {:c 42}}})
;; => {:a {:b 42}}
----

Let's take a look at a combinator that will let us build a unit-conversion lens
called `units`. We have to supply a function to convert from unit `a` to unit `b`
and viceversa:

.Example definiting a "unit conversion" lense
[source, clojure]
----
(defn sec->min [sec] (/ sec 60))
(defn min->sec [min] (* min 60))

(def mins (l/units sec->min
                   min->sec))

(l/focus mins 120)
;; => 2

(l/put mins 3 120)
;; => 180

(l/over mins inc 60)
;; => 120
----

And conditional lenses that can be defined using a predicate function and
returns a lens that focuses in an element only if it passes the predicate:

.Example focusing using conditional lenses
[source, clojure]
----
(l/focus (l/passes even?) 2)
;; => 2

(l/over (l/passes even?) inc 2)
;; => 3

(l/put (l/passes even?) 42 2)
;; => 42

(l/focus (l/passes even?) 1)
;; => nil

(l/over (l/passes even?) inc 1)
;; => 1

(l/put (l/passes even?) 42 1)
;; => 1
----

==== Interoperability

There are also `Focus` type that allows you to derive atom like objects from
clojure atoms focusing to a specific portion of it using lenses.

Let see an example focusing on a concrete set of keys on an asociative
data structure referenced by an atom:

[source, clojure]
----
(def state (atom {:x 1 :y 2 :z 3}))

(def state-d
  (l/focus-atom (l/select-keys [:x :y]) state))

@state-d
;; => {:x 1 :y 2}
----

The object returned by `focus-atom` function behaves identically to a clojure
atom and it can be treated as drop in replacement of it:

[source, clojure]
----
(swap! state-d update :x inc)

@state
;; => {:x 2 :y 2 :z 3}

@state-d
;; => {:x 2 :y 2}
----

And do not forget that you also can attach watchers to focused atoms in the same
way as you will do that with clojure(script) atoms.


[[traversals]]
=== Traversals

*Status:* Experimental

A traversal is similar to a lens but it focuses on multiple values instead of one.


==== First steps

Therefore, we use the `foci` function for viewing the focused elements of a
traversal.

Let's look at the identity traversal, it's called `it`:

[source, clojure]
----
(require '[cats.labs.traversals :as t])
(t/foci t/it 42)
;; => (42)

(t/foci t/it [0 1 2 3])
;; => ([0 1 2 3])

(t/put t/it 42 [0 1 2 3])
;; => 42

(t/over t/it count [0 1 2 3])
;; => 4
----


==== Traversals composition

Traversals like lenses are defined in terms of functions so the same approach
also applies to traversals. Them can be composed just using `comp` or any
other function composition technique.

Traversals should be composed with other traversals. You can compose lenses
with a traversal but it will become a traversal and you will have to use `foci`
for viewing its values.


==== Builtin traversals

The `each` traversal focuses every value in a collection, allowing us to map
preservering structure. The `cat` traversal flattens a nested collection:

.Example using `each` traversal
[source, clojure]
----
(t/foci t/each [0 1 2 3])
;; => (0 1 2 3)

(t/over t/each inc [0 1 2 3])
;; => [1 2 3 4]

(t/put t/each 42 [0 1 2 3])
;; => [42 42 42 42]

(t/foci t/cat [[0 1 2] [3 4 5]])
;; => (0 1 2 3 4 5)

(t/over t/cat inc [[0 1 2] [3 4 5]])
;; => [[1 2 3] [4 5 6]]

(t/put t/cat 42 [[0 1 2] [3 4 5]])
;; => [[42 42 42] [42 42 42]]
----

The `filter` traversal can be used to filter can be used to filter the results
of another by composition:

.Example using `filter` traversal
[source, clojure]
----
(t/foci (comp t/each (t/filter odd?))
        [1 2 3 4 5])
;; => (1 3 5)

(t/over (comp t/each (t/filter odd?))
        inc
        [1 2 3 4 5])
;; => [2 2 4 4 6]

(t/put (comp t/each (t/filter odd?))
       42
       [1 2 3 4 5])
;; => [42 2 42 4 42]
----

Using `only` is equivalent to composing `each` and `filter`:

[source, clojure]
----
(t/foci (t/only odd?)
        [1 2 3 4 5])
;; => (1 3 5)

(t/over (t/only odd?)
        inc
        [1 2 3 4 5])
;; => [2 2 4 4 6]

(t/put (t/only odd?)
       42
       [1 2 3 4 5])
;; => [42 2 42 4 42]
----

Another interesting traversals include `keys` for focusing on map keys, `vals`
for focusing on map values, and `indexed` for focusing on index-value pairs.


==== Interoperability

There are also `Foci` type that allows you to derive atom like objects from
clojure atoms focusing to a specific portion of it using traversals.

Let see an example:

[source, clojure]
----
(require '[cats.labs.traversals :as t])

(def a (atom [1 2 3 4]))

(def fsa (t/foci-atom t/each a))

@fsa
;; => (1 2 3 4)

(reset! fsa 42)
;; => (42 42 42 42)

@a
;; => [42 42 42 42]
----

And do not forget that you also can attach watchers to focused atoms in the same
way as you will do that with clojure(script) atoms.


== Complementary libraries

Some monads are defined as separated package to avoid additional
and unnecesary dependencies to cats. Also, there are some libraries
that build higher-level abstractions on top of what cats offers.

* Promise monad (ClojureScript): https://github.com/funcool/promesa
* Promise monad (Clojure): https://github.com/funcool/promissum
* Concurrent data fetching: https://github.com/funcool/muse


== FAQ

=== What Clojure types implement some of the Category Theory abstractions?

In contrast to other similar libraries in Clojure, _cats_ doesn't intend to
extend Clojure types that don't act like containers. For example, Clojure
keywords are values but can not be containers so they should not extend any of
the previously explained protocols.

.Summary of Clojure types and implemented protocols
[options="header"]
|==========================================================================================
| Name     | Implemented protocols
| sequence | Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable
| vector   | Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable
| hash-set | Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus
| hash-map | Semigroup, Monoid
|==========================================================================================


== Developers Guide

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _cats_ should keep these important rules in mind.


=== Contributing

Unlike Clojure and other Clojure contributed libraries, _cats_ does not have many
restrictions for contributions. Just open an issue or pull request.

=== Editor integration

For making Emacs' clojure-mode treat `alet`, `mlet` et al like a `let` and indent
them correctly, you can use `define-clojure-indent` like in the following example:

[source, elisp]
----
(require 'clojure-mode)

(define-clojure-indent
  (alet 'defun)
  (mlet 'defun))
----


=== Source Code

_cats_ is open source and can be found on
link:https://github.com/funcool/cats[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/cats
----


=== Run tests

For running tests just execute this for clojure:

[source, text]
----
lein test
----

And this for clojurescript:

[source, text]
----
./scripts/build
node ./out/tests.js
----


=== License

[source,text]
----
Copyright (c) 2014-2016 Andrey Antukh <niwi@niwi.nz>
Copyright (c) 2014-2016 Alejandro Gómez <alejandro@dialelo.com>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
