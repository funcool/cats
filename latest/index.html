<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Andrey Antukh &amp;amp;amp; Alejandro Gómez">
<title>Cats Documentation</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #60a0b0; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #60a0b0; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #4070a0 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #4070a0 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #06287e } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #bb60d5 } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/asciidoctor.js/1.5.5-5/css/asciidoctor.min.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Cats Documentation</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh &amp;amp;amp; Alejandro Gómez</span><br>
<span id="revdate">2.2.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#user-guide">User Guide</a>
<ul class="sectlevel2">
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#functor">Functor</a></li>
<li><a href="#applicative">Applicative</a></li>
<li><a href="#foldable">Foldable</a></li>
<li><a href="#traversable">Traversable</a></li>
<li><a href="#monad">Monad</a></li>
<li><a href="#monadzero">MonadZero</a></li>
<li><a href="#monadplus">MonadPlus</a></li>
</ul>
</li>
<li><a href="#types">Types</a>
<ul class="sectlevel2">
<li><a href="#maybe">Maybe</a></li>
<li><a href="#either">Either</a></li>
<li><a href="#exception">Exception</a></li>
<li><a href="#built-in-types">Built in types</a></li>
</ul>
</li>
<li><a href="#syntax-sugar">Syntax sugar</a>
<ul class="sectlevel2">
<li><a href="#mlet">mlet</a></li>
<li><a href="#alet">alet</a></li>
</ul>
</li>
<li><a href="#higher-order-functions">Higher-order functions</a>
<ul class="sectlevel2">
<li><a href="#curry">curry</a></li>
<li><a href="#lift-m">lift-m</a></li>
</ul>
</li>
<li><a href="#labs">Labs</a>
<ul class="sectlevel2">
<li><a href="#test-check">test.check</a></li>
<li><a href="#channel">Channel</a></li>
<li><a href="#manifold-deferred">Manifold Deferred</a></li>
</ul>
</li>
<li><a href="#complementary-libraries">Complementary libraries</a></li>
<li><a href="#faq">FAQ</a>
<ul class="sectlevel2">
<li><a href="#what-clojure-types-implement-some-of-the-category-theory-abstractions">What Clojure types implement some of the Category Theory abstractions?</a></li>
</ul>
</li>
<li><a href="#developers-guide">Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#editor-integration">Editor integration</a></li>
<li><a href="#source-code">Source Code</a></li>
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="logo.png" alt="cats logo"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Category Theory and algebraic abstractions for Clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale"><a class="link" href="#rationale">Rationale</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main motivations for writing this library are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The existing libraries do not have support for ClojureScript.</p>
</li>
<li>
<p>We do not intend to write a little Haskell inside Clojure. We have adopted a
practical and Clojure like pragmatic approach, always with correctness in mind.</p>
</li>
<li>
<p>We do not like viral/copyleft like licenses and in contrast to other libraries
cats is licensed under the BSD (2 clauses) license.</p>
</li>
<li>
<p>We do not intend to only implement monads. Other category theory and algebraic
abstractions are also first class in cats.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="install"><a class="link" href="#install">Install</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The simplest way to use <em>cats</em> in a Clojure project is by including
it as a dependency in your <strong><em>project.clj</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">funcool/cats</span> <span class="tok-s">&quot;2.2.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And it works with the following platforms: <strong>jdk7</strong>, <strong>jdk8</strong>, <strong>node</strong>
(4.2.0, 5.10.1 and 6.2.0).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="user-guide"><a class="link" href="#user-guide">User Guide</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section introduces almost all the category theory and algebraic abstractions
that the <em>cats</em> library supports.</p>
</div>
<div class="paragraph">
<p>We will use <em>Maybe</em> for the example snippets, because it has support for all
the abstractions and is very easy to understand. You can read more about it in
the next section of this documentation.</p>
</div>
<div class="sect2">
<h3 id="semigroup"><a class="link" href="#semigroup">Semigroup</a></h3>
<div class="paragraph">
<p>A semigroup is an algebraic structure with an associative binary operation
(<code>mappend</code>). Most of the builtin collections form a semigroup because their
associative binary operation is analogous to Clojure&#8217;s <code>into</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5 6]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that the values it contains form a Semigroup, we can <code>mappend</code> multiple
<em>Maybe</em> values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Just [1 2 3 4 5 6]&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="monoid"><a class="link" href="#monoid">Monoid</a></h3>
<div class="paragraph">
<p>A Monoid is a Semigroup with an identity element (<code>mempty</code>). For the collection
types the <code>mempty</code> function is analogous to Clojure&#8217;s <code>empty</code>.</p>
</div>
<div class="paragraph">
<p>Given that the values it contains form a Semigroup, we can <code>mappend</code> multiple
<em>Maybe</em>, with Nothing being the identity element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just [1 2 3 4 5 6]&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="functor"><a class="link" href="#functor">Functor</a></h3>
<div class="paragraph">
<p>Let&#8217;s dive into the functor. The Functor represents some sort of "computational
context", and the abstraction consists of one unique function: <strong>fmap</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Signature of <strong>fmap</strong> function</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">fmap</span> <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">fv</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The higher-order function <strong>fmap</strong> takes a plain function as the first parameter and
a value wrapped in a functor context as the second parameter. It extracts the
inner value, applies the function to it and returns the result wrapped in same type
as the second parameter.</p>
</div>
<div class="paragraph">
<p>But what is the <strong>functor context</strong>? It sounds more complex than it is. A Functor
wrapper is any type that acts as "Box" and implements the <code>Context</code> and <code>Functor</code>
protocols.</p>
</div>
<div class="listingblock">
<div class="title">One good example of a functor is the <strong>Maybe</strong> type:</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>just</code> function is a constructor of the Just type that is part of the
Maybe monad.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see one example of using <strong>fmap</strong> over a <strong>just</strong> instance:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmap over <strong>just</strong> instance.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Maybe</strong> type also has another constructor: <code>nothing</code>. It represents the
absence of a value. It is a safe substitute for <code>nil</code> and may represent failure.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what happens if we perform the same operation as the previous example
over a <strong>nothing</strong> instance:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmap over <strong>nothing</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Oh, awesome, instead of raising a <code>NullPointerException</code>, it just returns
<strong>nothing</strong>. Another advantage of using the functor abstraction, is that it
always returns a result of the same type as its second argument.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of applying fmap over a Clojure vector:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmap over <strong>vector</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main difference compared to the previous example with Clojure&#8217;s map function,
is that map returns lazy seqs no matter what collection we pass to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; clojure.lang.LazySeq (cljs.core/LazySeq in ClojureScript)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But why can we pass vectors to the <code>fmap</code> function? Because some Clojure container
types like vectors, lists and sets, also implement the functor abstraction. See
the section on built-in types for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="applicative"><a class="link" href="#applicative">Applicative</a></h3>
<div class="paragraph">
<p>Let&#8217;s continue with applicative functors. The Applicative Functor represents
some sort of "computational context" like a plain Functor, but with the ability to
execute a function wrapped in the same context.</p>
</div>
<div class="paragraph">
<p>The Applicative Functor abstraction consists of two functions: <strong>fapply</strong> and
<strong>pure</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Signature of <strong>fapply</strong> function</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">[</span><span class="tok-nv">af</span> <span class="tok-nv">av</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the <strong>pure</strong> function will be explained later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The use case for Applicative Functors is roughly the same as for plain Functors:
safe evaluation of some computation in a context.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example to better understand the differences between functor and
applicative functor:</p>
</div>
<div class="paragraph">
<p>Imagine you have some factory function that, depending on the language, returns a
greeter function, and you only support a few languages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-greeter</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">String</span> <span class="tok-nv">lang</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-nv">lang</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-nv">name</span><span class="tok-p">))</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-nv">name</span><span class="tok-p">))</span>
    <span class="tok-nv">nil</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, before using the resulting greeter you should always defensively check if
the returned greeter is a valid function or a nil value.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s convert this factory to use the Maybe type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-greeter</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">String</span> <span class="tok-nv">lang</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-nv">lang</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-nv">name</span><span class="tok-p">)))</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-nv">name</span><span class="tok-p">)))</span>
    <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this version of the factory differs only slightly from the
original implementation. And this tiny change gives you a new superpower: you
can apply the returned greeter to any value without a defensive nil check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;es&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just &quot;Hola Alex&quot;&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just &quot;Hello Alex&quot;&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;it&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Moreover, the applicative functor comes with the <strong>pure</strong> function, which allows
you to put some value in side-effect-free context of the current type.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">pure</span> <span class="tok-nv">maybe/maybe-monad</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 5&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not understand the purpose of the <strong>pure</strong> function, the next sections
should clarify its purpose.</p>
</div>
</div>
<div class="sect2">
<h3 id="foldable"><a class="link" href="#foldable">Foldable</a></h3>
<div class="paragraph">
<p>The <strong>Foldable</strong> is a generic abstraction for data structures that can be folded. It
consists mainly on two functions: <code>foldl</code> and <code>foldr</code>. <code>foldl</code> is also known as
<code>reduce</code> or <code>inject</code> in other mainstream programming languages.</p>
</div>
<div class="paragraph">
<p>Both function have an identical signature and differ in how they traverse the
data structure. Let&#8217;s look at a little example using <code>foldl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">foldl</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that <code>foldl</code> is identical to the clojure <code>reduce</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the same operation can be done using <code>foldr</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">foldr</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-nv">wc</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">v</span> <span class="tok-nv">wc</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main difference between <code>foldl</code> and <code>reduce</code> is that <code>foldl</code> has a fixed
arity so all parameters are mandatory and <code>foldl</code> is a generic abstraction that
can work with other types apart from collections.</p>
</div>
<div class="paragraph">
<p>As we said previously, the <code>foldl</code> and <code>foldr</code> differ mainly on how they traverse
the data structure. Then, for understanding better how they work internally,
let&#8217;s see a graphical representation of the <code>foldl</code> execution model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>((((acc⊕1)⊕2)⊕3)⊕4)⊕5</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast to the <code>foldr</code> internal execution model that looks like that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>1⊕(2⊕(3⊕(4⊕(5⊕(wc)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In languages with strict argument evaluation, <code>foldr</code> does not have many
applications because when the data structure to fold grows it tends to consume
all the stack (causing the well known stack overflow). In case of Clojure,
the unique obvious case of using foldr is for small datastructures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/foldr</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">%1</span><span class="tok-p">)</span> <span class="tok-nv">%2</span><span class="tok-p">)</span> <span class="tok-o">&#39;</span><span class="tok-p">()</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100000</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; StackOverflowError</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Foldable</strong> abstraction is already implemented for Clojure vectors, lazy seqs
and ranges plus the cats maybe, either and validation types. Let see an example
how it behaves with maybe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/foldl</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%1</span> <span class="tok-nv">%2</span><span class="tok-p">))</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/foldl</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">%1</span> <span class="tok-nv">%2</span><span class="tok-p">))</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It there also other fold functions that are implemented in terms of the basic
<code>foldl</code> or <code>foldr</code> that can be <strong>foldm</strong> and <strong>foldmap</strong>. At this moment, cats comes
only with <strong>foldm</strong>.</p>
</div>
<div class="paragraph">
<p>The <strong>foldm</strong> function in analgous to the <code>foldl</code> in terms of how it does the
fold operation, with the difference that is aware of the monad context. Or in
other terms, it works with reducing function that return monad types.</p>
</div>
<div class="paragraph">
<p>Let see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">m-div</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">zero? </span><span class="tok-nv">y</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">m/foldm</span> <span class="tok-nv">m-div</span> <span class="tok-mi">1</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1/6&gt;</span>


<span class="tok-p">(</span><span class="tok-nf">m/foldm</span> <span class="tok-nv">m-div</span> <span class="tok-mi">1</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">0</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="traversable"><a class="link" href="#traversable">Traversable</a></h3>
<div class="paragraph">
<p>The <strong>Traversable</strong> is a generic abstraction for data structures that can be
traversed from left to right, running an Applicative action for each element.
Traversables must also be Functors and Foldables.</p>
</div>
<div class="paragraph">
<p>Note that, since Traversables use the Applicative&#8217;s <code>pure</code> operation, the context
of the applicative must be set when using the <code>traverse</code> function.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example: we have a vector with numbers that we want to map to
a Maybe value, and we want to aggregate the result in a Maybe. If any of the
actions fails (is Nothing) the resulting aggregate will be Nothing, but if all
succeed we preserve the vector&#8217;s structure inside a Just value.</p>
</div>
<div class="paragraph">
<p>First of all, we define the function that will transform a number to a Maybe.
Our function will wrap the value in a Just if it&#8217;s even and in a Nothing if it&#8217;s
not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">just-if-even</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">even?</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have a function that maps a value to the Maybe Applicative, we can
traverse a vector of numbers and aggregate a Maybe value. The applicatives will
be evaluated from left to right using the applicative&#8217;s <code>fapply</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.context</span> <span class="tok-ss">:as</span> <span class="tok-nv">ctx</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">ctx/with-context</span> <span class="tok-nv">maybe/context</span>
  <span class="tok-p">(</span><span class="tok-nf">m/traverse</span> <span class="tok-nv">just-if-even</span> <span class="tok-p">[]))</span>
<span class="tok-c1">;; =&gt; #&lt;Just []&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">ctx/with-context</span> <span class="tok-nv">maybe/context</span>
  <span class="tok-p">(</span><span class="tok-nf">m/traverse</span> <span class="tok-nv">just-if-even</span> <span class="tok-p">[</span><span class="tok-mi">2</span> <span class="tok-mi">4</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Just [2 4]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">ctx/with-context</span> <span class="tok-nv">maybe/context</span>
  <span class="tok-p">(</span><span class="tok-nf">m/traverse</span> <span class="tok-nv">just-if-even</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">ctx/with-context</span> <span class="tok-nv">maybe/context</span>
  <span class="tok-p">(</span><span class="tok-nf">m/traverse</span> <span class="tok-nv">just-if-even</span> <span class="tok-p">[</span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="monad"><a class="link" href="#monad">Monad</a></h3>
<div class="paragraph">
<p>Monads are the most discussed programming concept to come from category theory.
Like functors and applicatives, monads deal with data in contexts.</p>
</div>
<div class="paragraph">
<p>Additionally, monads can also transform contexts by unwrapping data, applying
functions to it and putting new values in a completely different context.</p>
</div>
<div class="paragraph">
<p>The monad abstraction consists of two functions: <strong>bind</strong> and <strong>return</strong></p>
</div>
<div class="listingblock">
<div class="title">Bind function signature.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">bind</span> <span class="tok-p">[</span><span class="tok-nv">mv</span> <span class="tok-nv">f</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, bind works much like a Functor but with inverted arguments. The
main difference is that in a monad, the function is responsible for wrapping a
returned value in a context.</p>
</div>
<div class="listingblock">
<div class="title">Example usage of the bind higher-order function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the key features of the bind function is that any computation executed
within the context of bind (monad) knows the context type implicitly. With this,
if you apply some computation over some monadic value and you want to return
the result in the same container context but don&#8217;t know what that container is,
you can use <code>return</code> or <code>pure</code> functions:</p>
</div>
<div class="listingblock">
<div class="title">Usage of return function in bind context.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>return</code> or <code>pure</code> functions, when called with one argument, try to use
the dynamic scope context value that&#8217;s set internally by the <code>bind</code> function.
Therefore, you can&#8217;t use them with one argument outside of a <code>bind</code> context.</p>
</div>
<div class="paragraph">
<p>We now can compose any number of computations using monad <strong>bind</strong>
functions. But observe what happens when the number of computations increases:</p>
</div>
<div class="listingblock">
<div class="title">Composability example of bind function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">b</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This can quickly lead to callback hell. To solve this, <em>cats</em> comes with a powerful
macro: <strong>mlet</strong></p>
</div>
<div class="listingblock">
<div class="title">Previous example but using <strong>mlet</strong> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">b</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="monadzero"><a class="link" href="#monadzero">MonadZero</a></h3>
<div class="paragraph">
<p>Some monads also have the notion of an identity element analogous to that of
Monoid. When calling <code>bind</code> on a identity element for a monad, the same value is
returned. This means that whenever we encounter the identity element in a monadic
composition it will short-circuit.</p>
</div>
<div class="paragraph">
<p>For the already familiar Maybe type the identity element is Nothing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mzero</span> <span class="tok-nv">maybe/maybe-monad</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Having an identity element we can make a monadic composition short-circuit using
a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/mzero</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the above example the predicate <code>(= a 2)</code> returns either a
monadic value <code>(m/return nil)</code> or the identity value for the maybe monad. This
can be captured in a function, which is available in <code>cats.core</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">guard</span>
  <span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">b</span>
    <span class="tok-p">(</span><span class="tok-nf">return</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">mzero</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example could be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">m/guard</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, using mlet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)]</span>
   <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="monadplus"><a class="link" href="#monadplus">MonadPlus</a></h3>
<div class="paragraph">
<p>MonadPlus is a complementary abstraction for Monads that support an associative
binary operation, analogous to that of a Semigroup. If the monad implements the
MonadZero and MonadPlus protocols it forms a monoid.</p>
</div>
<div class="paragraph">
<p>For the Maybe type, <code>mplus</code> acts similarly to a logical OR that treats <code>Nothing</code>
values as falsey.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="types"><a class="link" href="#types">Types</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section will take a tour over the types exposed in cats library and explain
how they can be used in the previously explained abstractions.</p>
</div>
<div class="sect2">
<h3 id="maybe"><a class="link" href="#maybe">Maybe</a></h3>
<div class="paragraph">
<p>This is one of the two most used monad types (also known as Optional in other
programming languages).</p>
</div>
<div class="paragraph">
<p>The Maybe monad represents encapsulation of an optional value; e.g. it is used
as the return type of functions which may or may not return a meaningful value
when they are applied. It consists of either an empty constructor (called None
or Nothing), or a constructor encapsulating the original data type A (e.g.
Just A or Some A).</p>
</div>
<div class="paragraph">
<p><em>cats</em>, implements two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Just</code> that represents a value in a context.</p>
</li>
<li>
<p><code>Nothing</code> that represents the abscense of value.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example creating instances of <code>Just</code> and <code>Nothing</code> types:</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other useful functions for working with maybe monad types in the same
namespace. See the API documentation for a full list of them. But here we will
explain a little relevant subset of them.</p>
</div>
<div class="paragraph">
<p>We mentioned above that <strong>fmap</strong> extracts the value from a functor context. You
will also want to extract values wrapped by <strong>just</strong> and you can do that with
<strong>from-maybe</strong>.</p>
</div>
<div class="paragraph">
<p>As we said previously, the Just or Nothing instances act like wrappers and
in some circumstances you will want extract the plain value from them. cats offers
the <code>from-maybe</code> function for that.</p>
</div>
<div class="listingblock">
<div class="title">Example using <strong>from-maybe</strong> to extract values wrapped by <strong>just</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>from-maybe</code> function is a specialized version of a more generic one:
<code>cats.core/extract</code>. The generic version is a polymorphic function and will
also work with different types of different monads.</p>
</div>
<div class="paragraph">
<p>For interoperability with Clojure and ClojureScript&#8217;s <code>IDeref</code> abstraction,
maybe values are derrefable.</p>
</div>
<div class="listingblock">
<div class="title">Example using <strong>deref</strong> to extract values wrapped by <strong>just</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="either"><a class="link" href="#either">Either</a></h3>
<div class="paragraph">
<p>Either is another type that represents a result of a computation, but (in
contrast with maybe) it can return some data with a failed computation result.</p>
</div>
<div class="paragraph">
<p>In <em>cats</em> it has two constructors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(left v)</code>: represents a failure.</p>
</li>
<li>
<p><code>(right v)</code>: represents a successful result.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Usage example of <strong>Either</strong> constructors.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.either</span> <span class="tok-ss">:refer</span> <span class="tok-ss">:all</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nb">right </span><span class="tok-ss">:valid-value</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Right [:valid-value :right]&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">left </span><span class="tok-s">&quot;Error message&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Either [Error message :left]&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Either is also (like Maybe) a Functor, Applicative Functor and Monad.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like Maybe, Either values can be dereferenced returning the value they contain.</p>
</div>
</div>
<div class="sect2">
<h3 id="exception"><a class="link" href="#exception">Exception</a></h3>
<div class="paragraph">
<p>Also known as the Try monad, as popularized by Scala.</p>
</div>
<div class="paragraph">
<p>It represents a computation that may either result in an exception or return
a successfully computed value. Is very similar to the Either monad, but is
semantically different.</p>
</div>
<div class="paragraph">
<p>It consists of two types: Success and Failure. The Success type is a simple
wrapper, like Right of the Either monad. But the Failure type is slightly different
from Left, because it always wraps an instance of Throwable (or any value in
cljs since you can throw arbitrary values in the JavaScript host).</p>
</div>
<div class="paragraph">
<p>The most common use case of this monad is to wrap third party libraries that
use standard Exception based error handling. Under normal circumstances,
however, you should use Either instead.</p>
</div>
<div class="paragraph">
<p>It is an analogue of the try-catch block: it replaces try-catch&#8217;s stack-based
error handling with heap-based error handling. Instead of having an exception
thrown and having to deal with it immediately in the same thread, it disconnects
the error handling and recovery.</p>
</div>
<div class="listingblock">
<div class="title">Usage example of <strong>try-on</strong> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.exception</span> <span class="tok-ss">:as</span> <span class="tok-nv">exc</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Success [1]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Failure [#&lt;NullPointerException java.lang.NullPointerException&gt;]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>cats</em> comes with other syntactic sugar macros: <code>try-or-else</code> that returns a
default value if a computation fails, and <code>try-or-recover</code> that lets you handle
the return value when executing a function with the exception as first parameter.</p>
</div>
<div class="listingblock">
<div class="title">Usage example of <code>try-or-else</code> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">exc/try-or-else</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Success [2]&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Usage example of <code>try-or-recover</code> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">exc/try-or-recover</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">e</span><span class="tok-p">]</span>
                      <span class="tok-p">(</span><span class="tok-nf">cond</span>
                        <span class="tok-p">(</span><span class="tok-nb">instance? </span><span class="tok-nv">NullPointerException</span> <span class="tok-nv">e</span><span class="tok-p">)</span> <span class="tok-mi">0</span>
                        <span class="tok-ss">:else</span> <span class="tok-mi">100</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Success [0]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The types defined for the Exception monad (Success and Failure) also implement
the Clojure IDeref interface, which allows library development using monadic
composition without forcing a user of that library to use or understand monads.</p>
</div>
<div class="paragraph">
<p>That is because when you dereference the failure instance, it will reraise the
enclosed exception.</p>
</div>
<div class="listingblock">
<div class="title">Example dereferencing a failure instance</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)))</span>

<span class="tok-o">@</span><span class="tok-nv">f</span>
<span class="tok-c1">;; =&gt; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="built-in-types"><a class="link" href="#built-in-types">Built in types</a></h3>
<div class="paragraph">
<p>Some of the abstractions in <em>cats</em> are implemented for built-in types but you
can&#8217;t use them directly. First, you must load the <code>cats.builtin</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 3 4 5]</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="nil"><a class="link" href="#nil">nil</a></h4>
<div class="paragraph">
<p>Given the fact that <code>nil</code> is both a value and a type, we have extended the <code>nil</code>
type to be equivalent to Maybe monad&#8217;s <code>Nothing</code>. This means that you can use
<code>nil</code> as if were a <code>Just</code> instance like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
         <span class="tok-nv">y</span> <span class="tok-nv">nil</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>mlet</code> short-circuits when encountering a <code>nil</code> value.</p>
</div>
</div>
<div class="sect3">
<h4 id="vector"><a class="link" href="#vector">Vector</a></h4>
<div class="paragraph">
<p>Clojure vectors also participate in several of the abstractions implemented
in <em>cats</em>, most notably as a monad. Compare the following <code>for</code> comprehension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (4 5 6 5 6 7)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with the equivalent using <em>mlet</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
         <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; [4 5 6 5 6 7]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the symmetry between <code>for</code> and <code>mlet</code>. This is not accidental, both are
what is called a monad comprehension, the difference is that <code>for</code> is limited to
sequences and <code>mlet</code> can work with arbitrary monads.</p>
</div>
<div class="paragraph">
<p>Also, since <code>mlet</code> desugars into calls to the Monad&#8217;s <code>bind</code> function, its result
keeps the type of the monadic values.</p>
</div>
</div>
<div class="sect3">
<h4 id="lazy-sequences"><a class="link" href="#lazy-sequences">Lazy sequences</a></h4>
<div class="paragraph">
<p>Lazy sequences implement the same abstractions as vectors with practically an
identical implementation. If you don&#8217;t need the results right away or are
interested in a subset of the final results, you can use lazy sequence
comprehensions.</p>
</div>
<div class="paragraph">
<p>Using <code>mlet</code> with lazy sequences yields exactly the same result as using <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">lazy-seq</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
         <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">lazy-seq</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; (4 5 6 5 6 7)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="set"><a class="link" href="#set">Set</a></h4>
<div class="paragraph">
<p>Sets implement almost every abstraction in <em>cats</em>, from Semigroup to Monad.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/pure</span> <span class="tok-nv">set-context</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{42}</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{4 3 2 5}</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">)}))</span>
<span class="tok-c1">;; =&gt; #{1 4 3 2}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="map"><a class="link" href="#map">Map</a></h4>
<div class="paragraph">
<p>Maps implement the <em>Semigroup</em> protocol, since we can use <code>merge</code> as their
associative binary operation. Using <code>mappend</code> on maps is a way to merge them
together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-s">&quot;A&quot;</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:b</span> <span class="tok-s">&quot;B&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:a &quot;A&quot;, :b &quot;B&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since we can consider the empty map an identity element for the <code>mappend</code>
associative binary operation maps also implement <em>Monoid</em> and the <code>mempty</code>
function gives an empty map.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="syntax-sugar"><a class="link" href="#syntax-sugar">Syntax sugar</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Additionally to the abstractions and types, <strong>cats</strong> exposes some powerful
syntax abstractions that surelly will make the usage of that abstractions
in a more familiar way.</p>
</div>
<div class="sect2">
<h3 id="mlet"><a class="link" href="#mlet">mlet</a></h3>
<div class="paragraph">
<p>The <code>mlet</code> syntactic abstraction intends to facilitate the composition
of monadic operations.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve followed along with the documentation you&#8217;ve seen many examples
of its usage already, let&#8217;s see what can <code>mlet</code> do. First of all, mlet turns
this let-like bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>into a chain of calls to bind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That makes a lot more natural to write code that uses monads and gives a very
familiar <code>let</code> like syntax abstraction that makes the clojure code that uses
monads less "strange".</p>
</div>
<div class="paragraph">
<p>If you are coming from Haskell, mlet is mostly analogous to the <strong>do notation</strong>.</p>
</div>
<div class="paragraph">
<p>Since the bindings in the mlet macro run the monadic effects of the right-hand
values we cannot just put any value in there and expect to be bound to its
left symbol. For cases where we want the regular behavior of let we can inline
a <code>:let</code> clause, just like with Clojure&#8217;s <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))</span>
         <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)]]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">z</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>mlet</code> has support for using guards using a <code>:when</code> clause, analogous to the
one used in <code>for</code>. We can filter out values using <code>bind</code> with <code>mlet</code> and
<code>:when</code> like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)]</span>
   <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Any monadic type that implements <code>MonadZero</code> can be combined with guards
inside <code>mlet</code> bindings. Here is an example with vectors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">]</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">]</span>
         <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nf">odd?</span> <span class="tok-nv">a</span><span class="tok-p">)]</span>
   <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; [2 6]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="alet"><a class="link" href="#alet">alet</a></h3>
<div class="paragraph">
<p>One limitation of monadic bind is that all the steps are strictly sequential and
happen one at a time. This piece of code illustrates the usage of monadic bind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">bind</span> <span class="tok-nv">return</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">bind</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
        <span class="tok-p">(</span><span class="tok-nf">bind</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
              <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
                <span class="tok-p">(</span><span class="tok-nf">return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">))))))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the first call to <code>bind</code>, <code>(just 1)</code> and the anonymous function will be
evaluated. The call of the anonymous function performed by the first <code>bind</code>
will cause the evaluation of the <code>(just 41)</code> and the next anonymous function,
which will be also called to create the final result. Note that <code>(just 1)</code>
and <code>(just 41)</code> are independent and thus could be evaluated at the same time.</p>
</div>
<div class="paragraph">
<p>Here is the <code>mlet</code> version for reference and clarity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
       <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nf">return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s see the equivalent using <code>alet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">alet</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nf">alet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
       <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that no <code>return</code> is used, this is because the <code>alet</code> body runs inside
the applicative context with <code>fapply</code>. This is roughly what <code>alet</code> desugars to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
           <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nf">do</span>
               <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">))))</span>
         <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">41</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 42&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that now <code>(just 1)</code> and <code>(just 41)</code> are evaluated at the same time. This
use of <code>fapply</code> can be called "applicative bind" and in some cases is more
efficient than monadic bind. Furthermore, the <code>alet</code> macro splits the bindings
into batches that have dependencies only in previous values and evaluates all
applicative values in the batch at the same time.</p>
</div>
<div class="paragraph">
<p>This makes no difference at all for Maybe, but applicatives that have latency
in their calculations (for example promises that do an async computation) get
a pretty good evaluation strategy, which can minimize overall latency. In the
next examples we use the <a href="https://github.com/funcool/promesa">promesa</a>
clj/cljs library for emulate asynchronous behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.labs.promise</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promesa.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sleep-promise</span>
  <span class="tok-s">&quot;A simple function that emulates an</span>
<span class="tok-s">  asynchronous operation.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">wait</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nb">resolve </span><span class="tok-nv">reject</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">future</span>
                 <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-nv">wait</span><span class="tok-p">)</span>
                 <span class="tok-p">(</span><span class="tok-nb">resolve </span><span class="tok-nv">wait</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; note: deref-ing for blocking the current thread</span>
<span class="tok-c1">;; waiting for the promise being delivered</span>

<span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
           <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))))</span>
<span class="tok-c1">;; &quot;Elapsed time: 84.328182 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 83</span>

<span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
           <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; &quot;Elapsed time: 44.246427 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 83</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example for illustrating dependencies between batches:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
           <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
           <span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))</span>
           <span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">y</span><span class="tok-p">))]</span>
   <span class="tok-p">(</span><span class="tok-nf">m/return</span>  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">z</span> <span class="tok-nv">a</span><span class="tok-p">))))</span>
<span class="tok-c1">;; &quot;Elapsed time: 194.253182 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 85</span>

<span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
           <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)</span>
           <span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">x</span><span class="tok-p">))</span>
           <span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">y</span><span class="tok-p">))]</span>
    <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">z</span> <span class="tok-nv">a</span><span class="tok-p">)))</span>
<span class="tok-c1">;; &quot;Elapsed time: 86.20699 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 85</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="higher-order-functions"><a class="link" href="#higher-order-functions">Higher-order functions</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="curry"><a class="link" href="#curry">curry</a></h3>
<div class="paragraph">
<p>The first combinator that <em>cats</em> provides is a <code>curry</code> macro. Given a function,
it can convert it to a curried versions of itself. The generated function will
accept parameters until all the expected parameters are given.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see some examples of a curried function in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried-add</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-nv">add</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">curried-add</span> <span class="tok-p">(</span><span class="tok-nf">curried-add</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see above, since the original <code>add</code> has a single arity (3) and is
fixed (i.e. it doesn&#8217;t accept a variable number of arguments), the <code>curry</code> macro
was able to generate a curried function with the correct number of parameters.</p>
</div>
<div class="paragraph">
<p>This doesn&#8217;t mean that functions with multiple arities or variadic arguments
can&#8217;t be curried but an arity for the curried function must be given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">curried+</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Curried functions are very useful in combination with the applicative&#8217;s
<code>fapply</code> operation, since we can curry a function and use applicatives for
building up results with context-specific effects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/&lt;*&gt;</span> <span class="tok-p">(</span><span class="tok-nf">m/&lt;$&gt;</span> <span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lift-m"><a class="link" href="#lift-m">lift-m</a></h3>
<div class="paragraph">
<p>The <code>lift-m</code> macro is a combinator for promoting functions that work on
regular values to work on monadic values instead. It uses the monad&#8217;s bind
operation under the hood and, like <code>curry</code>, can be used without specifying arity
if the function we are lifting has a fixed and a single arity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/lift-m</span> <span class="tok-nv">add</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; #&lt;Nothing&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with <code>curry</code>, we must provide an arity in case we are lifting a function
that has multiple arities or is variadic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/lift-m</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; #&lt;Nothing&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can combine both <code>curry</code> and <code>lift-m</code> to get curried functions
that work on monadic types using the <code>curry-lift-m</code> macro. The arity is
mandatory when using this macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/curry-lift-m</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">((</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">((</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="labs"><a class="link" href="#labs">Labs</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section intends to explain different kind of extra features that can be
found under <strong>cats.labs</strong> namespace. The fact that they are here because they
are experimental, requires external dependencies or simply does not have much
application in clojure(script).</p>
</div>
<div class="paragraph">
<p>In any case the state of each module will be notified on the start of the
each section.</p>
</div>
<div class="sect2">
<h3 id="test-check"><a class="link" href="#test-check">test.check</a></h3>
<div class="paragraph">
<p><strong>Status:</strong> Experimental</p>
</div>
<div class="paragraph">
<p>The <code>cats.labs.test</code> namespace implements monad and applicative instances for
generators, which lets you use the <code>cats.core/alet</code> and <code>cats.core/mlet</code> macros
for writing generators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.labs.test</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">clojure.test.check.generators</span> <span class="tok-ss">:as</span> <span class="tok-nv">gen</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">color</span>
  <span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">r</span> <span class="tok-nv">gen/int</span>
           <span class="tok-nv">g</span> <span class="tok-nv">gen/int</span>
           <span class="tok-nv">b</span> <span class="tok-nv">gen/int</span><span class="tok-p">]</span>
    <span class="tok-p">[</span><span class="tok-nv">r</span> <span class="tok-nv">g</span> <span class="tok-nv">b</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-nf">gen/sample</span> <span class="tok-nv">color</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0 0 0])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mcolor</span>
  <span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">r</span> <span class="tok-nv">gen/int</span>
           <span class="tok-nv">g</span> <span class="tok-nv">gen/int</span>
           <span class="tok-nv">b</span> <span class="tok-nv">gen/int</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">[</span><span class="tok-nv">r</span> <span class="tok-nv">g</span> <span class="tok-nv">b</span><span class="tok-p">])))</span>

<span class="tok-p">(</span><span class="tok-nf">gen/sample</span> <span class="tok-nv">mcolor</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; ([0 0 0])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Apart from that, the namespace contains multiple functions for generating test.check
properties that verify the laws of Semigroup, Monoid, Functor, Applicative, Monad,
MonadZero and MonadPlus.</p>
</div>
<div class="paragraph">
<p>The implementation of cats' abstractions are tested using generative testing and
the <code>cats.labs.test</code> property generation functions.</p>
</div>
</div>
<div class="sect2">
<h3 id="channel"><a class="link" href="#channel">Channel</a></h3>
<div class="paragraph">
<p><strong>Status:</strong> Experimental</p>
</div>
<div class="paragraph">
<p>This namespace exposes the ability to use the <strong>core.async</strong> channel as monadic
type and in consequence use it in <code>mlet</code> or <code>alet</code> macros.</p>
</div>
<div class="paragraph">
<p>Before use it, you should add core.async to your dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">org.clojure/core.async</span> <span class="tok-s">&quot;0.2.385&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let see some code. This will allow you understand how it can be used and
why this integration between cats and core.async matters. At first step we will
go to define a function that emulates whatever asynchronous task, that for
our case it&#8217;s consist in a just sleep operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">clojure.core.async</span> <span class="tok-ss">:as</span> <span class="tok-nv">a</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.labs.channel</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">async-call</span>
  <span class="tok-s">&quot;A function that emulates some asynchronous call.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">a/go</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;---&gt; sending request&quot;</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">a/&lt;!</span> <span class="tok-p">(</span><span class="tok-nf">a/timeout</span> <span class="tok-nv">n</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;&lt;--- receiving request&quot;</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-nv">n</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, instead of using the <code>go</code> macro, just use a <code>let</code> like bindings with the
help of the <strong>mlet</strong> macro for bind values to asyncrhonous calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-p">(</span><span class="tok-nf">&lt;!!</span> <span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
               <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)]</span>
        <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))))</span>
<span class="tok-c1">;; ---&gt; sending request 200</span>
<span class="tok-c1">;; &lt;--- receiving request 200</span>
<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &quot;Elapsed time: 302.236804 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 300</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we can observe few things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The asynchronous calls are made serially.</p>
</li>
<li>
<p>We are calling a function that return a channel and bind its value to a symbol.</p>
</li>
<li>
<p>At the end, an operation is performed with the <code>mlet</code> bindings.</p>
</li>
<li>
<p>The <code>mlet</code> macro also returns a channel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The main difference with the default clojure <code>let</code>, is that the bindings
are already plain values (not channels). The take! operation is already
performed automatically by the <code>mlet</code>. This kind of behavior will make you
fully asynchronous code looks like synchronous code.</p>
</div>
<div class="paragraph">
<p>But, cats also comes with <code>alet</code> that has identical aspect to the previously
used <code>mlet</code> macro, but it has some advantages over it. Let see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
  <span class="tok-p">(</span><span class="tok-nf">a/&lt;!!</span> <span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
                  <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)]</span>
            <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &quot;Elapsed time: 101.06644 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 200</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here we can observe few things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The asynchronous calls are made in parallel.</p>
</li>
<li>
<p>The total time of processing is half less of if we use <code>mlet</code>.</p>
</li>
<li>
<p>The <code>return</code> function is not used because <code>alet</code> evaluates the body in the context
of the applicative.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The alet is a powerful macro that analyzes the dependencies between bindings
and executes the expressions in batches resultin in a very atractive feature
for asynchronous calls.</p>
</div>
<div class="paragraph">
<p>Here an other examples that shows in a clearly way how the batches are executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-p">(</span><span class="tok-nf">a/&lt;!!</span> <span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">120</span><span class="tok-p">)</span>
                 <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">130</span><span class="tok-p">)</span>
                 <span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-p">(</span><span class="tok-nb">- </span><span class="tok-nv">x</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
                 <span class="tok-nv">u</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-p">(</span><span class="tok-nb">- </span><span class="tok-nv">y</span> <span class="tok-mi">100</span><span class="tok-p">))</span>
                 <span class="tok-nv">t</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">u</span><span class="tok-p">))]</span>
          <span class="tok-nv">z</span><span class="tok-p">))))</span>
<span class="tok-c1">;; ---&gt; sending request  130</span>
<span class="tok-c1">;; ---&gt; sending request  120</span>
<span class="tok-c1">;; &lt;--- receiving request  120</span>
<span class="tok-c1">;; &lt;--- receiving request  130</span>
<span class="tok-c1">;; ---&gt; sending request  20</span>
<span class="tok-c1">;; ---&gt; sending request  30</span>
<span class="tok-c1">;; &lt;--- receiving request  20</span>
<span class="tok-c1">;; &lt;--- receiving request  30</span>
<span class="tok-c1">;; ---&gt; sending request  31</span>
<span class="tok-c1">;; &lt;--- receiving request  31</span>
<span class="tok-c1">;; &quot;Elapsed time: 194.536235 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 20</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="manifold-deferred"><a class="link" href="#manifold-deferred">Manifold Deferred</a></h3>
<div class="paragraph">
<p><strong>Status:</strong> Experimental</p>
</div>
<div class="paragraph">
<p>This namespace exposes the ability to use the <strong>manifold</strong> deferred as monadic
type and in consequence use it in <code>mlet</code> or <code>alet</code> macros.</p>
</div>
<div class="paragraph">
<p>Before use it, you should add manifold to your dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">[</span><span class="tok-nv">manifold</span> <span class="tok-s">&quot;0.1.1&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let see some code. This will allow you understand how it can be used
and why this integration between cats and manifold matters. At first step we
will go to define a function that emulates whatever asynchronous task, that for
our case it&#8217;s consist in a just sleep operation:</p>
</div>
<div class="paragraph">
<p>For demostration purposes, let&#8217;s define a function that emulates the asyncrhonous
call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.labs.manifold</span> <span class="tok-ss">:as</span> <span class="tok-nv">mf</span><span class="tok-p">]</span>
         <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">manifold.deferred</span> <span class="tok-ss">:as</span> <span class="tok-nv">d</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">async-call</span>
  <span class="tok-s">&quot;A function that emulates some asynchronous call.&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">n</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">d/future</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;---&gt; sending request&quot;</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;&lt;--- receiving request&quot;</span> <span class="tok-nv">n</span><span class="tok-p">)</span>
    <span class="tok-nv">n</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, the manifold deferreds can participate in the monad/applicative abstractions
using <code>mlet</code> and <code>alet</code> respectivelly.</p>
</div>
<div class="listingblock">
<div class="title">Example using manifold deferred with <code>mlet</code>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
  <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
            <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))))</span>
<span class="tok-c1">;; ---&gt; sending request 200</span>
<span class="tok-c1">;; &lt;--- receiving request 200</span>
<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &quot;Elapsed time: 302.236804 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 200</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are familiar with manifold&#8217;s <code>let-flow</code> macro, the cats <code>alet</code> serves
for almost identical purpose, with difference that <code>alet</code> is defined as
generic abstraction instread of a specific purpose macro.</p>
</div>
<div class="listingblock">
<div class="title">Example using manifold deferred with <code>alet</code>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span></span><span class="tok-p">(</span><span class="tok-nf">time</span>
  <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
            <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">async-call</span> <span class="tok-mi">100</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))))</span>

<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; ---&gt; sending request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &lt;--- receiving request 100</span>
<span class="tok-c1">;; &quot;Elapsed time: 101.06644 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 200</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="complementary-libraries"><a class="link" href="#complementary-libraries">Complementary libraries</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Promise monad: <a href="https://github.com/funcool/promesa" class="bare">https://github.com/funcool/promesa</a></p>
</li>
<li>
<p>Concurrent data fetching: <a href="https://github.com/funcool/urania" class="bare">https://github.com/funcool/urania</a></p>
</li>
<li>
<p>Pattern matching for the Cats' types: <a href="https://github.com/zalando/cats.match" class="bare">https://github.com/zalando/cats.match</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="link" href="#faq">FAQ</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what-clojure-types-implement-some-of-the-category-theory-abstractions"><a class="link" href="#what-clojure-types-implement-some-of-the-category-theory-abstractions">What Clojure types implement some of the Category Theory abstractions?</a></h3>
<div class="paragraph">
<p>In contrast to other similar libraries in Clojure, <em>cats</em> doesn&#8217;t intend to
extend Clojure types that don&#8217;t act like containers. For example, Clojure
keywords are values but can not be containers so they should not extend any of
the previously explained protocols.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Summary of Clojure types and implemented protocols</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Implemented protocols</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hash-set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hash-map</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developers-guide"><a class="link" href="#developers-guide">Developers Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="philosophy"><a class="link" href="#philosophy">Philosophy</a></h3>
<div class="paragraph">
<p>Five most important rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Beautiful is better than ugly.</p>
</li>
<li>
<p>Explicit is better than implicit.</p>
</li>
<li>
<p>Simple is better than complex.</p>
</li>
<li>
<p>Complex is better than complicated.</p>
</li>
<li>
<p>Readability counts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All contributions to <em>cats</em> should keep these important rules in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="contributing"><a class="link" href="#contributing">Contributing</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contributed libraries, <em>cats</em> does not have many
restrictions for contributions. Just open an issue or pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="editor-integration"><a class="link" href="#editor-integration">Editor integration</a></h3>
<div class="paragraph">
<p>For making Emacs' clojure-mode treat <code>alet</code>, <code>mlet</code> et al like a <code>let</code> and indent
them correctly, you can use <code>define-clojure-indent</code> like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="elisp"><span></span><span class="tok-p">(</span><span class="tok-nb">require</span> <span class="tok-ss">&#39;clojure-mode</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nv">define-clojure-indent</span>
  <span class="tok-p">(</span><span class="tok-nv">alet</span> <span class="tok-ss">&#39;defun</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nv">mlet</span> <span class="tok-ss">&#39;defun</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="source-code"><a class="link" href="#source-code">Source Code</a></h3>
<div class="paragraph">
<p><em>cats</em> is open source and can be found on
<a href="https://github.com/funcool/cats">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>git clone https://github.com/funcool/cats</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run-tests"><a class="link" href="#run-tests">Run tests</a></h3>
<div class="paragraph">
<p>For running tests just execute this for clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>lein test</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this for clojurescript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>./scripts/build
node ./out/tests.js</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="license"><a class="link" href="#license">License</a></h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text"><span></span>Copyright (c) 2014-2016 Andrey Antukh &lt;niwi@niwi.nz&gt;
Copyright (c) 2014-2016 Alejandro Gómez &lt;alejandro@dialelo.com&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-01-11 09:53:43 CET
</div>
</div>
</body>
</html>
